<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">

    <!-- Document meta -->
    <title>Test your Android App !</title>
        <meta name="author" content="mederic.hurier@uni.lu" />
            <meta name="description" content="Introduction to Android's testing frameworks">
    
    <!-- Slideshow theming -->
    <link rel="stylesheet" href="revealjs/css/reveal.css">
        <link rel="stylesheet" href="revealjs/css/theme/white.css" id="theme">
        <link rel="stylesheet" href="custom/global.css">
    <link rel="stylesheet" href="custom/local.css">

    <!-- Syntax highlighting -->
        <link rel="stylesheet" href="revealjs/lib/css/zenburn.css">
    
    <!-- PDF printing -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'revealjs/css/print/pdf.css' : 'revealjs/css/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h1>Test your Android App !</h1>
                        <h3>mederic.hurier@uni.lu</h3>
            
                    </section>

                <section id="toc">
            <h2>Outline</h2>

            <nav id="TOC">
                <ul>
                <li><a href="#/motivation">Motivation</a></li>
                <li><a href="#/unit-tests">Unit Tests</a></li>
                <li><a href="#/uiactivity-tests">UI/Activity Tests</a></li>
                <li><a href="#/tutorial-favorite">Tutorial: Favorite</a></li>
                </ul>
            </nav>
        </section>
        
        <section><section id="motivation" class="titleslide slide level1"><h1>Motivation</h1></section><section id="whats-your-opinion" class="slide level2">
        <h1>What's your opinion ?</h1>
        <ul>
        <li>In which case should you test a software ?
        <p class="fragment fade-in">
        <em>For every piece of code someone else will use or maintain</em>
        </p></li>
        <li>When should you start writing your test ?
        <p class="fragment fade-in">
        <em>Before your start coding (ideally) or the second after</em>
        </p></li>
        <li>Who should test your app ?
        <p class="fragment fade-in">
        <em>Yourself (unit test), your team (integration test)</em> <br> <em>beta users (validation test)</em> <strong>but not your Final User !</strong>
        </p></li>
        </ul>
        </section><section id="why-are-test-so-important" class="slide level2">
        <h1>Why are test so important ?</h1>
        <figure>
        <img src="img/grind-my-gears.jpg" />
        </figure>
        </section><section id="what-does-this-function-do-c" class="slide level2">
        <h1>What does this function do (C) ?</h1>
        <figure>
        <img src="img/epic-jackie-chan.jpg" />
        </figure>
        </section><section id="follow-best-practices" class="slide level2">
        <h1>Follow Best Practices</h1>
        <p>Well-written tests can help you to catch bugs early in development and give you confidence in your code.</p>
        <ul>
        <li><p><a href="http://www.agilemanifesto.org/">Agile Software Development</a></p></li>
        <li><p><a href="https://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development (TDD)</a></p></li>
        <li><p><a href="https://developer.android.com/training/testing.html">Android Best Practices for Test</a></p></li>
        </ul>
        <p><strong>During this course, we will review the last one together.</strong></p>
        </section><section id="definitions" class="slide level2">
        <h1>Definitions</h1>
        <p><strong>Unit Tests</strong> generally test the smallest possible unit of code without dependencies on system or network resources.</p>
        <p><strong>Test Cases</strong> define a set of objects and methods to run multiple tests independently from each other.</p>
        <p>Test cases can be organized into <strong>Test Suites</strong> and run programmatically, in a repeatable manner, with a <strong>Test Runner</strong> provided by a <strong>Testing Framework</strong>.</p>
        <p><strong>Test Fixtures</strong> consist of objects that must be initialized for running one or more tests</p>
        </section><section id="principles" class="slide level2">
        <h1>Principles</h1>
        <p>In order to verify that there are no regressions in the functional behavior of your application, it's important to <strong>create a test for each important Class of your project</strong>.</p>
        <p>For each test, you need to create the individual parts of a test case, including the <em>test fixture</em>, <em>preconditions test method</em>, and <em>test methods</em>.</p>
        <p>You can then run your test to get a <strong>Test Report</strong>.</p>
        <p>If any test method fails, this might indicate a defect.</p>
        </section><section class="slide level2">
        
        <figure>
        <img src="img/unit-tests.jpg" />
        </figure>
        </section><section id="conventions" class="slide level2">
        <h1>Conventions</h1>
        <p><strong>Tests are written in a structured way</strong>:</p>
        <ul>
        <li><p>create a class per test case, and a test case for each class</p></li>
        <li><p>put your tests in a separate package, distinct from the code under test (e.g. androidTest or test)</p></li>
        <li><p><strong>package name</strong> should have the same name as the package you want to test, suffixed with &quot;.tests&quot;</p></li>
        <li><p><strong>test case name</strong> should have the same name as the class you want to test, suffixed with &quot;Test&quot;</p></li>
        </ul>
        </section><section id="android-tools" class="slide level2">
        <h1>Android Tools</h1>
        <ul>
        <li><p><strong>Android Testing Support Library</strong>: provides a set of APIs that allow you to build and run test code for your apps.</p>
        <ul>
        <li><p><strong>AndroidJUnitRunner</strong>: JUnit 4-compatible test runner</p></li>
        <li><p><strong>Espresso</strong>: UI testing framework; use a programmatic approach for the functional testing within an app</p></li>
        <li><p><strong>UI Automator</strong>: UI testing framework; suitable for cross-app testing across system and installed apps</p></li>
        </ul></li>
        <li><p><strong>Monkey</strong>: generates pseudo-random streams of user events such as clicks, touches, or gestures.</p></li>
        </ul>
        </section></section>
        <section><section id="unit-tests" class="titleslide slide level1"><h1>Unit Tests</h1></section><section id="test-cases" class="slide level2">
        <h1>Test Cases</h1>
        <p>You should build unit tests when you need to verify the logic of some specific and independent code in your app.</p>
        <p>For example, if you are unit testing a class, your test might check that the class is in the right state after a method call</p>
        <p><strong>Unit tests are not suitable for testing complex scenario, such as interaction with the User Interface !</strong></p>
        <p>Instead, you should use the UI testing frameworks</p>
        </section><section id="test-categories" class="slide level2">
        <h1>Test Categories</h1>
        <p><strong>Local tests</strong>: units tests that run on your local machine only to minimize execution time and resource usage.</p>
        <p>Use this approach to run unit tests that have no dependencies on the Android framework or have dependencies that can be filled by using mock objects.</p>
        <p><strong>Instrumented tests</strong>: unit tests that run on an Android device or emulator. These tests have access to instrumentation information, such as the Context for the app under test.</p>
        <p>Use this approach to run tests that have Android dependencies which cannot be filled by using mock objects.</p>
        </section><section id="test-creation" class="slide level2">
        <h1>Test Creation</h1>
        <p>You need to create a <em>Java Class</em> inside your test package.</p>
        <p>Here is an example with <em>MainActivity</em>:</p>
        <figure>
        <img src="img/unit-creation.png" />
        </figure>
        </section><section id="test-definition" class="slide level2">
        <h1>Test Definition</h1>
        <p>Use the decorator @Test to annotate <strong>Test Methods</strong></p>
        <pre><code>        import org.junit.*;
        
        @RunWith(AndroidJUnit4.class)
        public class TestFoobar {
            @Test
            public void testOneThing() {
                // Code that tests one thing
            }
        
            @Test
            public void testAnotherThing() {
                // Code that tests another thing
            }
        }</code></pre>
        <p><strong>@Test(timeout=&lt;milliseconds&gt;)</strong>: Specifies a timeout period for the test. If the test starts but does not complete within the given timeout period, it automatically fails</p>
        </section><section id="prepost-execution" class="slide level2">
        <h1>Pre/Post Execution</h1>
        <ul>
        <li><strong>@Before</strong>: will be invoked before each test
        <ul>
        <li>you can have multiple <span class="citation" data-cites="Before">@Before</span> methods</li>
        </ul></li>
        <li><strong>@After</strong>: will be called after every test method
        <ul>
        <li>you can define multiple <span class="citation" data-cites="After">@After</span> methods</li>
        </ul></li>
        <li><strong>@BeforeClass</strong>: will be invoked once at initialization
        <ul>
        <li>your can have a single <span class="citation" data-cites="BeforeClass">@BeforeClass</span> methods</li>
        </ul></li>
        <li><strong>@AfterClass</strong>: will be invoked once at finalization
        <ul>
        <li>your can have a single <span class="citation" data-cites="AfterClass">@AfterClass</span> methods</li>
        </ul></li>
        </ul>
        <p><strong>Note</strong>: the order in which methods are called is not fixed.</p>
        </section><section class="slide level2">
        
        <pre><code>        import org.junit.*;
        
        @RunWith(AndroidJUnit4.class)
        public class TestFoobar {
            @BeforeClass
            public static void setUpClass() {}
        
            @Before
            public void setUp() {}
        
            @After
            public void tearDown() {}
        
            @AfterClass
            public static void tearDownClass() {}
        }</code></pre>
        </section><section id="precondition-test" class="slide level2">
        <h1>Precondition Test</h1>
        <p>As a sanity check, it is good practice to verify that the test fixture has been set up correctly, and the objects that you want to test have been correctly instantiated or initialized.</p>
        <pre><code>    public void testPreconditions() {
            assertNotNull(“activity is null”, activity);
            assertNotNull(“text is null”, text);
        }</code></pre>
        <p>By convention, the method for verifying your test fixture is called <em>testPreconditions()</em></p>
        </section><section id="test-assertions" class="slide level2">
        <h1>Test Assertions</h1>
        <p>You can use <strong>Test Assertions</strong> to verify a specific condition.</p>
        <ul>
        <li><p>If the condition is true, <strong>the test passes</strong>.</p></li>
        <li><p>If the condition is false, the assertion method throws an <strong>AssertionFailedError Exception</strong>.</p></li>
        <li><p>In both cases, the test runner proceeds to run the other test methods in the test case.</p></li>
        </ul>
        <p><strong>Note</strong>: you can provide a string in the first argument of your assertion method to give some contextual details</p>
        </section><section id="assert-methods-12" class="slide level2">
        <h1>Assert Methods 1/2</h1>
        <ol type="1">
        <li><strong>void assertEquals(boolean expected, boolean actual)</strong>
        <ul>
        <li>check that two primitives/Objects are equal</li>
        </ul></li>
        <li><strong>void assertTrue(boolean expected, boolean actual)</strong>
        <ul>
        <li>check that a condition is true</li>
        </ul></li>
        <li><strong>void assertFalse(boolean condition)</strong>
        <ul>
        <li>check that a condition is false</li>
        </ul></li>
        <li><strong>void assertNotNull(Object object)</strong>
        <ul>
        <li>check that an object isn't null.</li>
        </ul></li>
        </ol>
        </section><section id="assert-methods-22" class="slide level2">
        <h1>Assert Methods 2/2</h1>
        <ol start="5" type="1">
        <li><strong>void assertNull(Object object)</strong>
        <ul>
        <li>check that an object is null</li>
        </ul></li>
        <li><strong>void assertSame(boolean condition)</strong>
        <ul>
        <li>check if two references point to the same object</li>
        </ul></li>
        <li><strong>void assertNotSame(boolean condition)</strong>
        <ul>
        <li>check if two references not point to the same object</li>
        </ul></li>
        <li><strong>void assertArrayEquals(expectedArray, resultArray);</strong>
        <ul>
        <li>check whether two arrays are equal to each other.</li>
        </ul></li>
        </ol>
        </section><section id="test-execution" class="slide level2">
        <h1>Test Execution</h1>
        <p>Right click on your test folder &gt; Run tests in ...</p>
        <figure>
        <img src="img/run-all-the-tests.jpg" />
        </figure>
        </section><section class="slide level2">
        
        <p>You can then create a configuration to run all the tests.</p>
        <figure>
        <img src="img/save-test-configuration.png" />
        </figure>
        <p>And view the Test Result at the bottom of Android Studio</p>
        <figure>
        <img src="img/test-results.png" />
        </figure>
        </section></section>
        <section><section id="uiactivity-tests" class="titleslide slide level1"><h1>UI/Activity Tests</h1></section><section id="what-is-ui-testing" class="slide level2">
        <h1>What is UI Testing ?</h1>
        <p>User Interface (UI) testing lets you ensure that your app meets its functional requirements and achieves a high standard of quality such that it is more likely to be successfully adopted by users.</p>
        <figure>
        <img src="img/ui.png" />
        </figure>
        </section><section id="alternatives" class="slide level2">
        <h1>Alternatives</h1>
        <p>One approach to UI testing is to simply have a human tester perform a set of user operations on the target app and verify that it is behaving correctly. However, this manual approach can be time-consuming, tedious, and error-prone.</p>
        <p>A more efficient approach is to write your UI tests such that user actions are performed in an automated way. The automated approach allows you to run your tests quickly and reliably in a repeatable manner.</p>
        </section><section id="white-box-vs-black-box-testing" class="slide level2">
        <h1>White Box vs Black Box Testing</h1>
        <p><strong>White-Box Testing</strong>: you have the source code for the application that you want to test. The Android Instrumentation framework is suitable for creating white-box tests for UI components within an application.</p>
        <p><strong>Black-Box Testing</strong>: you may not have access to the application source. This type of testing is useful when you want to test how your app interacts with external apps.</p>
        </section><section id="for-single-app" class="slide level2">
        <h1>For single app</h1>
        <p>This type of test verifies that the target app behaves as expected when a user performs a specific action.</p>
        <p>It allows you to check that the app returns the correct output in response to user interactions.</p>
        <p>UI testing frameworks like <strong>Espresso</strong> allow you to programmatically simulate user actions.</p>
        <p><a href="https://developer.android.com/training/testing/ui-testing/espresso-testing.html" class="uri">https://developer.android.com/training/testing/ui-testing/espresso-testing.html</a></p>
        </section><section id="for-multiple-apps" class="slide level2">
        <h1>For multiple apps</h1>
        <p>This type of test verifies the correct behavior of interactions between different user apps or between apps.</p>
        <p>For example, you might want to test that your camera app shares images correctly with a 3rd-party social media app.</p>
        <p>UI testing frameworks that support cross-app interactions, such as <strong>UI Automator</strong>, allow you to create such scenarios.</p>
        <p><a href="https://developer.android.com/training/testing/ui-testing/uiautomator-testing.html" class="uri">https://developer.android.com/training/testing/ui-testing/uiautomator-testing.html</a></p>
        </section><section id="unit-tests-for-activities" class="slide level2">
        <h1>Unit Tests for Activities</h1>
        <p>To create a unit test for your Activity, use a @Rule decorator</p>
        <pre><code>        @RunWith(AndroidJUnit4.class)
        public class MainActivityTest {
        
            @Rule
            public ActivityTestRule&lt;MainActivity&gt; activity
                = new ActivityTestRule&lt;&gt;(MainActivity.class);
        
            @Test
            public void exampleTest() {
            }
        }</code></pre>
        </section><section id="more-test-annotations" class="slide level2">
        <h1>More Test Annotations</h1>
        <p>Android annotations let you classify how long a test should take to determine how frequently the test should run.</p>
        <p><strong>@SmallTests</strong> (execution time: &lt; 100ms) <br /> these tests should be run very frequently</p>
        <p><strong>@MediumTests</strong> (execution time: &lt; 2s) <br /> these tests run at least on every check in of your code</p>
        <p><strong>@LargeTests</strong> (execution time: &lt; 120s) <br /> these tests should be run as often as practical (once a day)</p>
        </section><section id="simple-example" class="slide level2">
        <h1>Simple Example</h1>
        <p>You can add a test method like this to test your UI:</p>
        <pre><code>        @Test
        public void topAndBottomWidgetsAreDisplayed() {
            onView(withId(R.id.ip_label))
                .check(matches(isDisplayed()));
            onView(withId(R.id.hex_check))
                .check(matches(isDisplayed()));
        }</code></pre>
        <p>This method checks that the two most extreme views are correctly displayed to the user.</p>
        </section></section>
        <section><section id="tutorial-favorite" class="titleslide slide level1"><h1>Tutorial: Favorite</h1></section><section id="scope" class="slide level2">
        <h1>Scope</h1>
        <p><strong>Included</strong>:</p>
        <ul>
        <li><p>Unit and UI/Activity Testing</p></li>
        <li><p>Mock of Android Framework</p></li>
        <li><p>Introduction to Monkey</p></li>
        </ul>
        <p><strong>Excluded</strong>:</p>
        <ul>
        <li><p>Service/Content Provider Testing</p></li>
        <li><p>Performance Testing</p></li>
        </ul>
        </section><section id="your-challenge" class="slide level2">
        <h1>Your Challenge</h1>
        <p>You have an existing Android App called &quot;Favorite&quot;</p>
        <p><a href="https://github.com/fmind/favorite" class="uri">https://github.com/fmind/favorite</a></p>
        <p><strong>NOTE</strong>: This is an application for geeks only !</p>
        <p>You have to register your favorite things, such as IP Address, Binary Numbers, and Hexadecimal Numbers</p>
        <p>Unfortunately, there is no tests for this app. You must create them to improve its quality and maintainability</p>
        </section><section id="demo" class="slide level2">
        <h1>Demo</h1>
        <figure>
        <img src="img/favorite.png" />
        </figure>
        </section><section id="instrumented-testing" class="slide level2">
        <h1>#1 Instrumented Testing</h1>
        <ul>
        <li><p>Fill the methods in main Validators.java</p></li>
        <li><p>Complete the units test in ValidatorsTest.java</p></li>
        <li><p>Ask me to come and try to mess with your tests ;)</p></li>
        </ul>
        <p>If your computer is not powerful enough to run an emulator, convert them to local tests and run them on your machine</p>
        <p>(move the class from app/src/androidTest to app/src/test).</p>
        </section><section class="slide level2">
        
        <p><strong>To run Instrumented Unit Tests in Android Studio</strong>:</p>
        <ol type="1">
        <li>Right-click on the file and select &quot;Run ClassTest&quot;
        <ul>
        <li>this works for the navigation menu and in the editor</li>
        <li>you can also right click on a test method specifically</li>
        </ul></li>
        </ol>
        <figure>
        <img src="img/top-menu.png" />
        </figure>
        <ol start="2" type="1">
        <li>Then, you can run the same test from the top menu</li>
        </ol>
        </section><section id="activity-testing" class="slide level2">
        <h1>#2 Activity Testing</h1>
        <p><strong>Open MainActivityTest.java and fill the test methods</strong></p>
        <ul>
        <li><p>Check that the text inputs are empty by default</p></li>
        <li><p>Check that checkboxes are unchecked by default</p></li>
        <li><p>Check that checkboxes are not clickable by default</p></li>
        <li><p>Check the validation when a user submit an IP Address</p></li>
        </ul>
        </section><section id="local-unit-testing" class="slide level2">
        <h1>#3 Local Unit Testing</h1>
        <p><strong>Open ContextReaderTest.java and fill the test methods</strong></p>
        <ul>
        <li>Mock calls to Context methods from ContextReader
        <ul>
        <li>if it helps, look at the class imports and this link</li>
        </ul></li>
        </ul>
        <p><a href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html">Document for Mokito on: site.mockito.org</a></p>
        <p><strong>Migrate your test class for Validators to become local tests</strong> - since the test are local, they should be faster to execute</p>
        </section><section id="monkey-testing" class="slide level2">
        <h1>#4 Monkey Testing</h1>
        <p>Run the following code in your shell:</p>
        <pre><code>adb shell monkey -p edu.ul.android.favorite -v 1500</code></pre>
        <p>Give me your feedback ;)</p>
        </section><section id="documentations" class="slide level2">
        <h1>Documentations</h1>
        <ul>
        <li><p><a href="https://www.udacity.com/courses/android" class="uri">https://www.udacity.com/courses/android</a></p></li>
        <li><p><a href="https://developer.android.com/studio/test/index.html" class="uri">https://developer.android.com/studio/test/index.html</a></p></li>
        <li><p><a href="https://developer.android.com/training/testing/index.html" class="uri">https://developer.android.com/training/testing/index.html</a></p></li>
        </ul>
        </section></section>
    </div>
</div>
<script src="revealjs/lib/js/head.min.js"></script>
<script src="revealjs/js/reveal.js"></script>
<script>
    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        history: true,
        controls: false,
        slideNumber: true,
        /* width: 960, */
        /* height: 700, */
                                        transition: Reveal.getQueryHash().transition || 'zoom',
                // Optional reveal.js plugins
        dependencies: [
            { src: 'revealjs/lib/js/classList.js', condition: function() { return !document.body.classList; } },
            { src: 'revealjs/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'revealjs/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'revealjs/plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
            { src: 'revealjs/plugin/zoom-js/zoom.js', async: true },
            { src: 'revealjs/plugin/notes/notes.js', async: true },
            { src: 'revealjs/plugin/math/math.js', async: true },
        ]
    });
</script>
</body>
</html>
